<!DOCTYPE html>
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Chat Overlay</title>
    <style>
        /* Animation */
        @keyframes fadeInUp {
            from {
                transform: translate3d(0, 40px, 0)
            }

            to {
                transform: translate3d(0, 0, 0);
                opacity: 1
            }
        }
			::-webkit-scrollbar {
  width: 8px;
}

::-webkit-scrollbar-track {
  background: black;
  border-radius: 5px;
}

::-webkit-scrollbar-thumb {
  background-color: #777;
  border-radius: 5px;}
        .animate {
            animation-duration: 0.3s;
            animation-fill-mode: both;
            -webkit-animation-duration: 0.3s;
            -webkit-animation-fill-mode: both;
            opacity: 0;
            animation-name: fadeInUp;
            -webkit-animation-name: fadeInUp;
        }
   body {
  margin: 0;
  height: 8500px;
  position: relative;
  overflow-x:hidden;
  overflow-y:auto;
}
#loading
{
opacity:1; /* Make it visible by default */
}
        @-webkit-keyframes fadeInUp {
            from {
                transform: translate3d(0, 40px, 0)
            }

            to {
                transform: translate3d(0, 0, 0);
                opacity: 1
            }
        }

        .animate {
            animation-duration: 0.3s;
            animation-fill-mode: both;
            -webkit-animation-duration: 0.3s;
            -webkit-animation-fill-mode: both;
            opacity: 0;
            animation-name: fadeInUp;
            -webkit-animation-name: fadeInUp;
        }

        @keyframes fadeOut {
            from {
                opacity: 1
            }

            to {
                opacity: 0
            }
        }

        @-webkit-keyframes fadeOut {
            from {
                opacity: 1
            }

            to {
                opacity: 0
            }
        }

        .fade-out { /* Changed from .fade to be more specific */
            animation-duration: 0.5s;
            animation-fill-mode: both;
            -webkit-animation-duration: 0.5s;
            -webkit-animation-fill-mode: both;
            animation-name: fadeOut;
            -webkit-animation-name: fadeOut;
        }



#chat-container {
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  font-size: 20px;
  width: calc(100% - 20px);
  padding: 10px;
  position: absolute;
  bottom: 0;
  overflow: hidden; /* Enable vertical scrolling */
  background-color: transparent;
  color: white;
  font-weight: 800;
  word-break: break-word;
}

        .chat_line {
            line-height: 30px;
        }

        .sender-info {
            display: inline-block;
        }

        .separator {
            margin-right: 8px;
        }

        .emote {
            max-width: 75px;
            max-height: 25px;
            margin-right: 4px;
            vertical-align: middle;
        }

        .badge {
            width: 16px;
            height: 16px;
            margin-right: 2px;
            margin-bottom: 3px;
            vertical-align: middle;
            border-radius: 10%;
        }

        img .emoji {
            max-width: 75px !important;
            max-height: 25px !important;
            margin-right: 4px !important;
            vertical-align: middle !important;
        }
    </style>
</head>
<body>
    <div id="chat-container">
        <span id="loading"></span>
    </div>
    <script src="https://unpkg.com/twemoji@14.0.2/dist/twemoji.min.js" crossorigin="anonymous"></script>
<script>
const urlParams = new URLSearchParams(window.location.search);
let user = urlParams.get('user'); // Changed to 'let' to allow modification
const customTheme = urlParams.get('customtheme');
const animate = urlParams.get('animate');
const fade = urlParams.get('fade');
const showBadges = urlParams.get('showbadges');
const hideCommands = urlParams.get('hidecommands');
const hideBots = urlParams.get('hidebots');
const textColor = '#' + urlParams.get('textcolor');
const textSize = urlParams.get('textsize');

// If no user is specified, redirect back to the root.
if (!user) {
    window.location.href = '/';
}

// Apply custom CSS theme if provided
if (customTheme) {
    let decodedCss = atob(customTheme);
    let styleSheet = document.createElement("style");
    let head = document.head || document.getElementsByTagName('head')[0];
    styleSheet.type = 'text/css';
    styleSheet.appendChild(document.createTextNode(decodedCss));
    console.log(decodedCss);
    head.appendChild(styleSheet);
}

// Global variable to hold subscriber badges data
let subBadges;


// --- 2. Fetch Channel Information ---

/**
 * Fetches channel data from the Kick API, including the channel ID and subscriber badges.
 * @param {string} username - The Kick username.
 * @returns {Promise<any>} A promise that resolves with the fetched data.
 */
async function fetchData(username) {
    let response;
    // Retry fetching until successful, to handle temporary network or API issues.
    while (!response || !response.ok) {
        try {
            response = await fetch(`https://kick.com/api/v2/channels/${username}`);
            if (!response.ok) {
                console.log(`Failed to fetch data: ${response.status}`, user);
                // Kick sometimes uses '-' instead of '_' for usernames in URLs
                if (response.status === 404 && user.includes('_')) {
                    user = user.replace(/_/g, '-');
                    username = username.replace(/_/g, '-');
                }
                // Wait for 5 seconds before retrying
                await new Promise(resolve => setTimeout(resolve, 5000));
            }
        } catch (error) {
            console.log(`Error fetching data: ${error}`, user);
            await new Promise(resolve => setTimeout(resolve, 5000));
        }
    }
    return response;
}

/**
 * Initializes the process by fetching channel info and then starting the main application.
 */
async function getChannelInfo() {
    const response = await fetchData(user);
    const channelData = await response.json();

    console.log("Response from Kick API:", response);
    console.log(`Successfully fetched data for user: ${user}`);
    console.log(`Chatroom ID: ${channelData.chatroom.id}`);

    // Sort subscriber badges by month, descending, to easily find the correct one.
    subBadges = channelData.subscriber_badges;
    subBadges.sort((a, b) => (a.months > b.months) ? -1 : 1);

    return channelData.chatroom.id;
}


// --- 3. WebSocket Connection & Main Logic ---

/**
 * Main function to connect to WebSocket and handle incoming messages.
 * @param {string} channelId - The ID of the chatroom to connect to.
 */
function main(channelId) {
    // --- Kick's Public Pusher Credentials ---
    const key = "4912e76426d255ae4a90";
    const cluster = "us2";

    // Establish WebSocket connection
    const socket = new WebSocket(`wss://ws-${cluster}.pusher.com/app/${key}?protocol=7&client=js&version=7.6.0&flash=false`);

    console.log("WebSocket connection initiated to Kick's Pusher instance.");

    socket.onopen = () => {
        console.log("WebSocket Connected. Subscribing to channel...");
        document.getElementById('loading').innerHTML = '<img src="https://files.kick.com/emotes/26/full/2x.png" class="badge gift"></img> Connected to Kick Chat';
        setTimeout(() => {
            document.getElementById('loading').style.display = 'none';
        }, 2000);

        const channelToSubscribe = `chatrooms.${channelId}.v2`; 
        
        console.log(`Subscribing to: ${channelToSubscribe}`);

        socket.send(JSON.stringify({
            event: 'pusher:subscribe',
            data: {
                channel: channelToSubscribe
            }
        }));
    };

    // --- THIS IS THE CRITICAL FIX ---
    socket.onmessage = (event) => {
        // Simply pass ALL incoming data to the parser.
        // The parser function will know how to handle different event types.
        parseMessage(event.data);
    };
    // --- END OF FIX ---

    socket.onerror = (error) => {
        console.error(`WebSocket Error:`, error);
    };

    socket.onclose = (event) => {
        console.log("WebSocket Connection Closed. Code:", event.code, "Reason:", event.reason);
        // You might want to add reconnection logic here.
    };

    // Keep the connection alive by sending a ping every 25 seconds
    setInterval(() => {
        if (socket.readyState === WebSocket.OPEN) {
            socket.send(JSON.stringify({
                event: 'pusher:ping',
                data: {}
            }));
        }
    }, 25000);
}


/**
 * Parses incoming WebSocket messages and routes them to the correct handler.
 * @param {string} rawData - The raw data string from the WebSocket.
 */
function parseMessage(rawData) {
    const message = JSON.parse(rawData);

    // FIX: Handle stringified JSON data from Kick
    let eventData;
    if (typeof message.data === 'string') {
        eventData = JSON.parse(message.data);
    } else {
        eventData = message.data;
    }
    
    // Route based on Kick's event names
    switch (message.event) {
        case 'pusher_internal:subscription_succeeded':
            console.log(`Successfully subscribed to channel: ${message.channel}`);
            break;
        case 'App\\Events\\ChatMessageEvent':
            // console.log("Message:", eventData); // You can uncomment this for debugging
            handleMessage(eventData);
            break;
        case 'App\\Events\\MessageDeletedEvent':
            console.log("Deleted:", eventData);
            handleDelete(eventData);
            break;
        case 'App\\Events\\UserBannedEvent':
            console.log("Banned:", eventData);
            handleBan(eventData);
            break;
        case 'App\\Events\\ChatClearEvent':
            console.log("Chat Cleared");
            handleClear(eventData);
            break;
        default:
            // Ignore other pusher-internal events and any others we don't care about
            if (!message.event.startsWith('pusher')) {
                console.log("Received unhandled event:", message.event);
            }
            break;
    }
}


// --- 4. Message & Event Handlers ---

/**
 * Renders a new chat message on the screen.
 * @param {object} messageData - The parsed message object from the API.
 */
function handleMessage(messageData) {
    const messageId = messageData.id;
    let content = messageData.content;
    const username = messageData.sender.username;
    const identity = messageData.sender.identity;
    const senderId = messageData.sender.id; // Get sender ID for ban handling

    if (hideCommands === 'true' && content.startsWith('!')) {
        return;
    }
    if (hideBots === 'true') {
        const bots = ['nightbot', 'botrix', 'botrixlive', 'streamlabs'];
        if (bots.includes(username.toLowerCase())) return;
    }

    // Replace emote codes with image tags
    content = content.replace(/\[emote:(\d+):?([\w\s\-~!@#$%^&*()_+=\{}\\|;:'",.<>\/?]+)\]/g, 
        '<img src="https://files.kick.com/emotes/$1/full/2x.gif" class="emote">');

    // Replace emoji codes with image tags
    content = content.replace(/\[emoji:(\w+)\]/g, 
        '<img src="https://files.kick.com/emojis/$1.png" class="emote">');

    // Create the message container element
    let messageElement = document.createElement('div');
    
    messageElement.classList.add('chat_line');
    if (animate) {
        messageElement.classList.add('animate');
    }
    
    messageElement.setAttribute('data-id', messageId);
    messageElement.setAttribute('data-sender', username);
    messageElement.setAttribute('data-sender-id', senderId); // Set sender ID attribute
    messageElement.setAttribute('data-timestamp', messageData.created_at);

    // Create container for badges and username
    let senderInfoElement = document.createElement('span');
    senderInfoElement.classList.add('sender-info');
    
    // Generate and add badges
    if (showBadges !== 'false') {
        senderInfoElement.innerHTML = generateBadges(messageData);
    } else {
        senderInfoElement.innerHTML = '';
    }

    // Create username element
    let usernameElement = document.createElement('span');
    usernameElement.classList.add('username');
    usernameElement.style.color = identity.color;
    usernameElement.innerHTML = username;

    // Create separator
    let separatorElement = document.createElement('span');
    separatorElement.classList.add('separator');
    separatorElement.innerHTML = ':\u00A0';

    // Append username and separator to the sender info container
    senderInfoElement.appendChild(usernameElement);
    senderInfoElement.appendChild(separatorElement);

    // Create message content element
    let contentElement = document.createElement('span');
    contentElement.classList.add('message-content');
    contentElement.innerHTML = content;

    // Apply text color and size if specified
    if (textColor && textColor !== '#') {
        contentElement.style.color = textColor;
    }
    if (textSize) {
        messageElement.style.fontSize = textSize;
    }

    // Assemble the full message element
    messageElement.appendChild(senderInfoElement);
    messageElement.appendChild(contentElement);

    // Fade out message after a delay
    if (fade) {
        setTimeout(() => {
            messageElement.classList.add('fade-out');
            setTimeout(() => {
                messageElement.remove();
            }, 1000); // Wait for fade-out animation to complete
        }, fade * 1000);
    }

    // Add the message to the chat container
    const chatContainer = document.getElementById('chat-container');
    chatContainer.appendChild(messageElement);

    // Limit the number of messages on screen to 100 to avoid performance issues
    let messages = document.querySelectorAll('.chat_line');
    if (messages.length > 100 && !fade) { // Only remove if not using fade
        messages[0].remove();
    }
}

/**
 * Removes a specific message by its ID.
 * @param {object} data - The deletion event data containing the message ID.
 */
function handleDelete(data) {
    const messageId = data.message.id;
    const messageElement = document.querySelector(`[data-id="${messageId}"]`);
    if (messageElement) {
        messageElement.remove();
    }
}

/**
 * Removes all messages from a specific user.
 * @param {object} data - The ban event data containing the user's information.
 */
function handleBan(data) {
    console.log(data);
    const userId = data.user.id;
    document.querySelectorAll(`[data-sender-id="${userId}"]`).forEach(el => el.remove());
}

/**
 * Removes all messages from the chat display.
 */
function handleClear() {
    document.getElementById('chat-container').innerHTML = '';
}


// --- 5. Badge Generation ---

/**
 * Generates the HTML for a user's badges based on their identity.
 * @param {object} messageData - The message object containing sender identity.
 * @returns {string} An HTML string of <img> tags for the badges.
 */
function generateBadges(messageData) {
    let badgesHtml = '';
    const badges = messageData.sender.identity.badges;

    badges.forEach(badge => {
        const badgeType = badge.type;
        switch (badgeType) {
            case 'broadcaster':
                badgesHtml += '<img src="https://files.kick.com/static/badges/broadcaster.svg" class="badge broadcaster">';
                break;
            case 'moderator':
                badgesHtml += '<img src="https://files.kick.com/static/badges/moderator.svg" class="badge moderator">';
                break;
            case 'vip':
                badgesHtml += `<img src="https://files.kick.com/static/badges/vip.png" class="badge vip" style="--badge-color: ${badge.data.color};">`;
                break;
            case 'og':
                badgesHtml += '<img src="https://files.kick.com/static/badges/og.svg" class="badge OG">';
                break;
            case 'subscriber':
                if (subBadges) {
                    const months = parseInt(badge.count);
                    const bestBadge = subBadges.find(b => b.months === months) || subBadges.find(b => b.months < months);
                    if (bestBadge) {
                        badgesHtml += `<img src="${bestBadge.badge_image.src}" class="badge subscriber">`;
                    }
                }
                break;
            case 'sub_gifter':
                const giftCount = parseInt(badge.count);
                if (giftCount >= 50) {
                    badgesHtml += '<img src="https://files.kick.com/static/badges/sub_gifter/v5.svg" class="badge subgift">';
                } else if (giftCount >= 25) {
                    badgesHtml += '<img src="https://files.kick.com/static/badges/sub_gifter/v4.svg" class="badge subgift">';
                } else if (giftCount >= 10) {
                    badgesHtml += '<img src="https://files.kick.com/static/badges/sub_gifter/v3.svg" class="badge subgift">';
                } else if (giftCount >= 5) {
                    badgesHtml += '<img src="https://files.kick.com/static/badges/sub_gifter/v2.svg" class="badge subgift">';
                } else if (giftCount >= 1) {
                    badgesHtml += '<img src="https://files.kick.com/static/badges/sub_gifter/v1.svg" class="badge subgift">';
                }
                break;
        }
    });

    return badgesHtml;
}


// --- 6. Application Start ---

getChannelInfo().then(channelId => {
    console.log(`Channel ID: ${channelId}`);
    main(channelId);
});
</script>
</body>
<script>
    // --- PAUSE ON SCROLL SCRIPT ---

    // The chat won't pause until at least this many messages exist.
    const MIN_MESSAGES_TO_PAUSE = 10;

    // --- STATE VARIABLES ---
    let isPaused = false;
    let lastScrollY = window.scrollY;

    // --- CREATE THE "CHAT PAUSED" BUTTON ---
    const pauseButton = document.createElement('button');
    const img = document.createElement("img");
    img.src = "./pause.jpg"; // Make sure this path is correct
    img.style.verticalAlign = "middle";
    img.style.width = "21px";
    img.style.height = "21px";
    img.style.marginRight = "10px";

    pauseButton.appendChild(img);
    pauseButton.appendChild(document.createTextNode('Chat Paused - Click to resume'));
    // Apply styles
    Object.assign(pauseButton.style, {
        position: 'fixed',
        bottom: '30px',
        left: '50%',
        transform: 'translateX(-50%)',
        width: '80%',
        maxWidth: '400px', // Set a max width
        padding: '10px 20px',
        fontSize: '18px',
        fontWeight: '600',
        background: 'rgba(0, 0, 0, 0.85)',
        color: 'white',
        display: 'none', // Initially hidden
        zIndex: '1000',
        borderRadius: '25px',
        border: '2px solid #00ff00', // Lime green
        cursor: 'pointer',
        boxShadow: '0 4px 12px rgba(0,0,0,0.4)',
        textAlign: 'center'
    });
    document.body.appendChild(pauseButton);


    // --- FUNCTIONS ---

    /**
     * Resumes the chat, hiding the pause button and scrolling to the bottom.
     */
    function resumeChat() {
        isPaused = false;
        pauseButton.style.display = 'none';

        // Show any messages that were hidden while paused
        document.querySelectorAll('.chat_line[data-hidden="true"]').forEach(element => {
            element.style.display = '';
            element.removeAttribute('data-hidden');
        });

        // Scroll smoothly to the bottom
        window.scrollTo({
            top: document.documentElement.scrollHeight,
            behavior: 'smooth'
        });
        
        // After scrolling, update lastScrollY to the new bottom position
        setTimeout(() => {
            lastScrollY = window.scrollY;
        }, 300); 
    }

    /**
     * Handles updates to the chat container, hiding new messages if paused,
     * or auto-scrolling if not.
     */
    function handleChatUpdate(mutationsList) {
        let hasNewMessage = false;
        for (const mutation of mutationsList) {
            if (mutation.type === 'childList') {
                for (const node of mutation.addedNodes) {
                    if (node.nodeType === 1 && node.classList.contains('chat_line')) {
                        hasNewMessage = true;
                        if (isPaused) {
                            node.style.display = 'none';
                            node.setAttribute('data-hidden', 'true');
                        }
                    }
                }
            }
        }

        if (hasNewMessage && !isPaused) {
            window.scrollTo(0, document.documentElement.scrollHeight);
            lastScrollY = document.documentElement.scrollHeight - window.innerHeight;
        }
    }


    /**
     * Checks scroll direction to determine if the chat should pause or resume.
     */
    function checkScrollPosition() {
        if (document.querySelectorAll('.chat_line').length < MIN_MESSAGES_TO_PAUSE) {
            return; 
        }

        const currentScrollY = window.scrollY;
        
        // PAUSE: If scrolled UP and not already paused.
        if (currentScrollY < lastScrollY && !isPaused && currentScrollY > 0) {
            isPaused = true;
            pauseButton.style.display = 'block';
        }

        // RESUME: If scrolled to the very bottom.
        const isAtVeryBottom = (window.innerHeight + currentScrollY) >= document.documentElement.scrollHeight - 5; // 5px buffer
        if (isAtVeryBottom && isPaused) {
            resumeChat();
        }

        lastScrollY = currentScrollY;
    }


    // --- SETUP OBSERVERS AND EVENT LISTENERS ---
    const chatContainer = document.getElementById('chat-container');
    const observer = new MutationObserver(handleChatUpdate);
    observer.observe(chatContainer, {
        childList: true,
    });

    pauseButton.addEventListener('click', resumeChat);

    let scrollTimeout;
    window.addEventListener('scroll', () => {
        clearTimeout(scrollTimeout);
        scrollTimeout = setTimeout(checkScrollPosition, 50);
    });

    // --- INITIAL SCROLL ---
    window.scrollTo(0, document.documentElement.scrollHeight);
    lastScrollY = window.scrollY;

</script>
</html>
