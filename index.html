<!DOCTYPE html>
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Chat Overlay</title>
    <style>
        /* Animation */
        @keyframes fadeInUp {
            from {
                transform: translate3d(0, 40px, 0)
            }

            to {
                transform: translate3d(0, 0, 0);
                opacity: 1
            }
        }
			::-webkit-scrollbar {
  width: 8px;
}

::-webkit-scrollbar-track {
  background: black;
  border-radius: 5px;
}

::-webkit-scrollbar-thumb {
  background-color: #777;
  border-radius: 5px;}
        .animate {
            animation-duration: 0.3s;
            animation-fill-mode: both;
            -webkit-animation-duration: 0.3s;
            -webkit-animation-fill-mode: both;
            opacity: 0;
            animation-name: fadeInUp;
            -webkit-animation-name: fadeInUp;
        }
   body {
  margin: 0;
  height: 8500px;
  position: relative;
  overflow-x:hidden;
  overflow-y:auto;
}
#loading
{
opacity:0;
}
        @-webkit-keyframes fadeInUp {
            from {
                transform: translate3d(0, 40px, 0)
            }

            to {
                transform: translate3d(0, 0, 0);
                opacity: 1
            }
        }

        .animate {
            animation-duration: 0.3s;
            animation-fill-mode: both;
            -webkit-animation-duration: 0.3s;
            -webkit-animation-fill-mode: both;
            opacity: 0;
            animation-name: fadeInUp;
            -webkit-animation-name: fadeInUp;
        }

        @keyframes fadeOut {
            from {
                opacity: 1
            }

            to {
                opacity: 0
            }
        }

        @-webkit-keyframes fadeOut {
            from {
                opacity: 1
            }

            to {
                opacity: 0
            }
        }

        .fade {
            animation-duration: 0.5s;
            animation-fill-mode: both;
            -webkit-animation-duration: 0.5s;
            -webkit-animation-fill-mode: both;
            animation-name: fadeOut;
            -webkit-animation-name: fadeOut;
        }



#chat-container {
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  font-size: 20px;
  width: calc(100% - 20px);
  padding: 10px;
  position: absolute;
  bottom: 0;
  overflow: hidden; /* Enable vertical scrolling */
  background-color: transparent;
  color: white;
  font-weight: 800;
  word-break: break-word;
}

        .chat_line {
            line-height: 30px;
        }

        .user_info {
            display: inline-block;
        }

        .colon {
            margin-right: 8px;
        }

        .emote {
            max-width: 75px;
            max-height: 25px;
            margin-right: 4px;
            vertical-align: middle;
        }

        .badge {
            width: 16px;
            height: 16px;
            margin-right: 2px;
            margin-bottom: 3px;
            vertical-align: middle;
            border-radius: 10%;
        }

        img .emoji {
            max-width: 75px !important;
            max-height: 25px !important;
            margin-right: 4px !important;
            vertical-align: middle !important;
        }
    </style>
</head>
<body>
    <div id="chat-container">
        <span id="loading"></span>
    </div>
    <script src="https://unpkg.com/twemoji@14.0.2/dist/twemoji.min.js" crossorigin="anonymous"></script>
<script>
	/**
 * Kick.com Custom Chat Overlay Script
 * 
 * This script connects to Kick's API and WebSocket to display a channel's chat messages.
 * It's designed to be used as a browser source in streaming software like OBS.
 * 
 * Customization is available via URL query parameters:
 * - user: The Kick username of the channel to display. (Required)
 * - showbadges: (e.g., "true" or "false") Toggles the display of user badges.
 * - hidecommands: (e.g., "true") Hides messages that start with '!'.
 * - hidebots: (e.g., "true") Hides messages from known bots.
 * - animate: (e.g., "true") Adds an animation to new messages.
 * - fade: (e.g., "10") Messages will fade out after this many seconds.
 * - textColor: Sets the color of the message text (e.g., "ffffff").
 * - textSize: Sets the font size of the messages (e.g., "16px").
 * - customtheme: A base64 encoded CSS string for custom styling.
 */

// --- 1. Initial Setup and URL Parameter Parsing ---

// Parse URL parameters to get customization options
const urlParams = new URLSearchParams(window.location.search);
const user = urlParams.get('user');
const animate = urlParams.get('animate');
const fade = urlParams.get('fade');
const showBadges = urlParams.get('showbadges');
const hideCommands = urlParams.get('hidecommands');
const hideBots = urlParams.get('hidebots');
const textColor = '#' + urlParams.get('textColor');
const textSize = urlParams.get('textSize');
const customTheme = urlParams.get('customtheme');

// If the 'user' parameter is missing, redirect to the root page.
if (!user) {
    window.location.replace('/');
}

let subBadges; // Will store subscriber badges fetched from the API

// --- 2. API and WebSocket Logic ---

/**
 * Asynchronously fetches data from a URL with a retry mechanism.
 * @param {string} url - The URL to fetch.
 * @returns {Promise<Response>} The fetch response object.
 */
async function fetchData(url) {
    let response;
    while (!response || !response.ok) {
        try {
            response = await fetch(url);
            if (!response.ok) {
                console.log('Failed to fetch, status: ' + response.status);
                // Handle 404s by retrying with a modified username if it contains underscores
                if (response.status === 404 && user.includes('_')) {
                    user = user.replace(/_/g, '-');
                    url = url.replace(/_/g, '-');
                }
                await new Promise(resolve => setTimeout(resolve, 5000)); // Wait 5 seconds before retrying
            }
        } catch (error) {
            console.log('Error fetching data: ' + error);
            await new Promise(resolve => setTimeout(resolve, 5000)); // Wait 5 seconds on network error
        }
    }
    return response;
}

/**
 * Fetches channel information from the Kick API, including the channel ID and subscriber badges.
 * @returns {Promise<number>} The channel ID.
 */
async function getChannelInfo() {
    const apiUrl = 'https://kick.com/api/v2/channels/' + user;
    const response = await fetchData(apiUrl);
    const channelData = await response.json();

    console.log("Response from Kick API:", response);
    console.log("Channel Info:", channelData);

    subBadges = channelData.subscriber_badges;
    // Sort badges by month count in descending order to find the best match later
    subBadges.sort((a, b) => (a.months > b.months ? -1 : 1));

    return channelData.chatroom.id;
}

/**
 * The main function that initializes the WebSocket connection and message handling.
 * @param {number} channelId - The ID of the channel's chatroom.
 */
function main(channelId) {
    const socket = new WebSocket('wss://ws-us-1.pusher.com/app/3062abac4458db6369f1?protocol=7&client=js&version=7.6.0&flash=false');

    socket.onclose = (event) => {
        console.log('Socket closed:', event);
    };

    socket.onopen = () => {
        console.log('Connected by Kick');
        document.getElementById('loading').style.display = 'none';

        // Subscribe to the channel's chatroom events
        const subscribePayload = {
            event: 'pusher:subscribe',
            data: {
                auth: '',
                channel: 'chatrooms.' + channelId + '.v2'
            }
        };
        socket.send(JSON.stringify(subscribePayload));
        
        // Keep the connection alive
        setInterval(() => {
            socket.send(JSON.stringify({ event: 'pusher:ping', data: {} }));
        }, 30000);
    };

    // Listen for incoming messages
    socket.onmessage = (event) => {
        parseMessage(event.data);
    };
}

// --- 3. Message Parsing and DOM Manipulation ---

/**
 * Parses incoming WebSocket messages and routes them to the correct handler.
 * @param {string} rawData - The raw data string from the WebSocket.
 */
function parseMessage(rawData) {
    const messageObject = JSON.parse(rawData);
    const eventData = JSON.parse(messageObject.data.replace(/\\u00a0/g, ' ').replace(/\\n/g, ' ').replace(/\\r/g, ' '));
    
    // Route event to the appropriate handler based on the event type
    switch (messageObject.event) {
        case 'App\\Events\\ChatMessageEvent':
            handleMessage(eventData);
            break;
        case 'App\\Events\\MessageDeletedEvent':
            handleDelete(eventData);
            break;
        case 'App\\Events\\UserBannedEvent':
            handleBan(eventData);
            break;
        case 'App\\Events\\ChatroomClearEvent':
            handleClear();
            break;
    }
}

/**
 * Renders a new chat message to the DOM.
 * @param {object} msgData - The message data object.
 */
function handleMessage(msgData) {
    const messageId = msgData.id;
    let content = msgData.content;
    const senderUsername = msgData.sender.username;
    const timestamp = msgData.created_at;

    if (hideCommands === 'true' && content.startsWith('!')) {
        return;
    }
    
    const knownBots = ['botrixlive', 'nightbot', 'streamlabs'];
    if (hideBots === 'true' && knownBots.includes(senderUsername.toLowerCase())) {
        return;
    }

    // Replace [emote:...] tags with <img> tags
    const emoteMatches = content.match(/\[emote:(\d+):?([\w\s\-~!@#$%^&*()_+=\{}\\|;:'",.<>\/?]+)\]/g);
    if (emoteMatches) {
        for (const emote of emoteMatches) {
            const emoteId = emote.match(/\[emote:(\d+):?.*\]/)[1];
            content = content.replace(emote, `<img src="https://files.kick.com/emotes/${emoteId}/fullsize" class="emote">`);
        }
    }
    
    // Replace [emoji:...] tags with the actual emoji character
    const emojiMatches = content.match(/\[emoji:(\w+)\]/g);
    if (emojiMatches) {
        for (const emoji of emojiMatches) {
            const emojiChar = emoji.match(/\[emoji:(\w+)\]/)[1];
            content = content.replace(emoji, emojiChar);
        }
    }

    // Create the message elements
    const messageDiv = document.createElement('div');
    messageDiv.classList.add('message');
    messageDiv.setAttribute('data-id', messageId);
    messageDiv.setAttribute('data-sender', senderUsername);
    messageDiv.setAttribute('data-timestamp', timestamp);

    const badgesAndUser = document.createElement('span');
    badgesAndUser.classList.add('user');
    
    if (showBadges === 'true') {
        badgesAndUser.innerHTML = generateBadgesHTML(msgData);
    } else {
        badgesAndUser.innerHTML = '';
    }

    const usernameSpan = document.createElement('span');
    usernameSpan.classList.add('username');
    usernameSpan.style.color = msgData.sender.identity.color;
    usernameSpan.innerHTML = senderUsername;

    const colonSpan = document.createElement('span');
    colonSpan.classList.add('colon');
    colonSpan.innerHTML = ': ';
    
    badgesAndUser.appendChild(usernameSpan);
    badgesAndUser.appendChild(colonSpan);

    const contentSpan = document.createElement('span');
    contentSpan.classList.add('content');
    contentSpan.innerHTML = content;

    if (textColor) {
        contentSpan.style.color = textColor;
    }
    if (textSize) {
        messageDiv.style.fontSize = textSize;
    }

    messageDiv.appendChild(badgesAndUser);
    messageDiv.appendChild(contentSpan);

    if (animate) {
        messageDiv.classList.add('animated');
    }
    if (fade) {
        setTimeout(() => messageDiv.classList.add('faded'), 500);
        setTimeout(() => messageDiv.remove(), fade * 1000);
    }
    
    // Add the message to the chat container and manage message limit
    const chatContainer = document.getElementById('chat-container');
    chatContainer.appendChild(messageDiv);
    
    if (chatContainer.children.length > 50) {
        chatContainer.children[0].remove();
    }
}

/**
 * Handles message deletion events.
 * @param {object} data - The deletion data, containing the message ID.
 */
function handleDelete(data) {
    const messageId = data.id;
    document.querySelector(`[data-id="${messageId}"]`)?.remove();
}

/**
 * Handles user ban events, removing all messages from that user.
 * @param {object} data - The ban data, containing the user's info.
 */
function handleBan(data) {
    const bannedUsername = data.user.username;
    document.querySelectorAll(`[data-sender="${bannedUsername}"]`).forEach(el => el.remove());
}

/**
 * Handles chat clear events.
 */
function handleClear() {
    document.getElementById('chat-container').innerHTML = '';
}


/**
 * Generates the HTML string for a user's badges.
 * @param {object} msgData - The full message data object.
 * @returns {string} The HTML string of <img> tags for the badges.
 */
function generateBadgesHTML(msgData) {
    let badgesHTML = '';
    const userBadges = msgData.sender.identity.badges;

    userBadges.forEach(badge => {
        switch (badge.type) {
            case 'og':
                badgesHTML += '<img src="https://files.kick.com/static/badges/og.png" class="badge og">';
                break;
            case 'vip':
                badgesHTML += '<img src="https://files.kick.com/static/badges/vip.png" class="badge vip">';
                break;
            case 'founder':
                badgesHTML += `<img src="${badge.badge_image.src}" class="badge founder">`;
                break;
            case 'moderator':
                badgesHTML += '<img src="https://files.kick.com/static/badges/moderator.svg" class="badge moderator">';
                break;
            case 'broadcaster':
                badgesHTML += '<img src="https://files.kick.com/static/badges/broadcaster.png" class="badge broadcaster">';
                break;
            case 'subscriber':
                if (subBadges) {
                    const months = parseInt(badge.count);
                    const bestBadge = subBadges.find(sb => sb.months === months) || subBadges.find(sb => sb.months < months);
                    if (bestBadge) {
                        badgesHTML += `<img src="${bestBadge.badge_image.src}" class="badge subscriber">`;
                    }
                }
                break;
            case 'sub_gifter':
                const giftCount = parseInt(badge.count);
                if (giftCount >= 50) {
                    badgesHTML += '<img src="https://files.kick.com/static/badges/sub_gifter/v5.svg" class="badge subgift">';
                } else if (giftCount >= 10) {
                    badgesHTML += '<img src="https://files.kick.com/static/badges/sub_gifter/v4.svg" class="badge subgift">';
                } else if (giftCount >= 5) {
                    badgesHTML += '<img src="https://files.kick.com/static/badges/sub_gifter/v3.svg" class="badge subgift">';
                } else if (giftCount >= 1) {
                    badgesHTML += '<img src="https://files.kick.com/static/badges/sub_gifter/v2.svg" class="badge subgift">';
                }
                break;
        }
    });
    return badgesHTML;
}

// --- 4. Initialization ---

// If a custom theme is provided via URL, inject it into the page.
if (customTheme) {
    let decodedCSS = atob(customTheme);
    let styleElement = document.createElement('style');
    let head = document.head || document.getElementsByTagName('head')[0];
    styleElement.type = 'text/css';
    styleElement.appendChild(document.createTextNode(decodedCSS));
    console.log("Applying custom theme:", decodedCSS);
    head.appendChild(styleElement);
}

// Start the process by fetching channel info and then connecting to the WebSocket.
getChannelInfo().then(channelId => {
    console.log("Channel ID: " + channelId);
    main(channelId);
});
</script>
</body>
<script>
    // The chat won't pause until at least this many messages exist.
    const MIN_MESSAGES_TO_PAUSE = 10;

    // --- STATE VARIABLES ---
    // isPaused: Our single source of truth. true = user has scrolled up, false = auto-scrolling.
    let isPaused = false;
    // lastScrollY: Tracks the last scroll position to detect scroll direction.
    let lastScrollY = window.scrollY;

    // --- CREATE THE "CHAT PAUSED" BUTTON ---
    const pauseButton = document.createElement('button');
    const img = document.createElement("img");
    img.src = "./pause.jpg"; // Make sure this path is correct
    img.style.verticalAlign = "middle";
    img.style.width = "21px";
    img.style.height = "21px";
    img.style.marginRight = "10px";

    pauseButton.appendChild(img);
    pauseButton.appendChild(document.createTextNode('Chat Paused - Click to resume'));
    // Apply styles
    Object.assign(pauseButton.style, {
        position: 'fixed',
        bottom: '30px',
        left: '50%',
        transform: 'translateX(-50%)',
        width: '80%',
        padding: '10px 20px',
        fontSize: '18px',
        fontWeight: '600',
        background: 'rgba(0, 0, 0, 0.85)',
        color: 'white',
        display: 'none', // Initially hidden
        zIndex: '1000',
        borderRadius: '25px',
        border: '2px solid #00ff00', // Lime green
        cursor: 'pointer',
        boxShadow: '0 4px 12px rgba(0,0,0,0.4)'
    });
    document.body.appendChild(pauseButton);


    // --- FUNCTIONS ---

    /**
     * Resumes the chat, hiding the pause button, showing all messages, and scrolling to the bottom.
     */
    function resumeChat() {
        isPaused = false;
        pauseButton.style.display = 'none';

        // Show any messages that were hidden while paused
        document.querySelectorAll('.chat_line.animate[data-hidden="true"]').forEach(element => {
            element.style.display = '';
            element.removeAttribute('data-hidden');
        });

        // Scroll smoothly to the bottom
        window.scrollTo({
            top: document.documentElement.scrollHeight,
            behavior: 'smooth'
        });
        
        // After scrolling, update lastScrollY to the new bottom position
        // Use a small delay to allow the scroll to complete
        setTimeout(() => {
            lastScrollY = window.scrollY;
        }, 300); // 300ms should be enough for a smooth scroll
    }

    /**
     * This function is the heart of the auto-scroll and pause logic.
     * It's called by the MutationObserver whenever the chat content changes.
     */
    function handleChatUpdate(mutationsList) {
        let hasNewMessage = false;
        for (const mutation of mutationsList) {
            if (mutation.type === 'childList') {
                for (const node of mutation.addedNodes) {
                    // Check if the added node is a new chat line we care about
                    if (node.nodeType === 1 && node.classList.contains('chat_line') && node.classList.contains('animate')) {
                        hasNewMessage = true;
                        if (isPaused) {
                            // If paused, hide the new message and mark it
                            node.style.display = 'none';
                            node.setAttribute('data-hidden', 'true');
                        }
                    }
                }
            }
        }

        // If new messages arrived AND we are not paused, scroll to the bottom.
        if (hasNewMessage && !isPaused) {
            window.scrollTo(0, document.documentElement.scrollHeight);
            // After auto-scrolling, update our last known position to the new bottom.
            lastScrollY = document.documentElement.scrollHeight - window.innerHeight;
        }
    }


    /**
     * Checks the user's scroll direction to determine if the chat should be paused.
     * It also checks if the user has scrolled back to the very bottom to resume.
     */
    function checkScrollPosition() {
        const chatLineCount = document.querySelectorAll('.chat_line.animate').length;
        if (chatLineCount < MIN_MESSAGES_TO_PAUSE) {
            return; // Don't allow pausing if chat is too short
        }

        const currentScrollY = window.scrollY;
        
        // --- PAUSE LOGIC ---
        // If the user scrolls UP (and we aren't already paused), pause the chat.
        // We add a small buffer (currentScrollY > 0) to avoid issues at the very top.
        if (currentScrollY < lastScrollY && !isPaused && currentScrollY > 0) {
            isPaused = true;
            pauseButton.style.display = 'block';
        }

        // --- RESUME LOGIC ---
        // If the user scrolls all the way to the bottom, resume the chat.
        const isAtVeryBottom = (window.innerHeight + currentScrollY) >= document.documentElement.scrollHeight;
        if (isAtVeryBottom && isPaused) {
            resumeChat();
        }

        // ALWAYS update the last scroll position for the next check.
        lastScrollY = currentScrollY;
    }


    // --- SETUP OBSERVERS AND EVENT LISTENERS ---

    // Create and start the MutationObserver to watch for new messages
    const observer = new MutationObserver(handleChatUpdate);
    observer.observe(document.body, {
        childList: true,
        subtree: true
    });

    // When the pause button is clicked, resume the chat.
    pauseButton.addEventListener('click', resumeChat);

    // Use a timeout to prevent the scroll check from running too frequently
    let scrollTimeout;
    window.addEventListener('scroll', () => {
        clearTimeout(scrollTimeout);
        scrollTimeout = setTimeout(checkScrollPosition, 50); // Check 50ms after the last scroll event
    });

    // --- INITIAL SCROLL ---
    // Start scrolled to the bottom when the page loads.
    window.scrollTo(0, document.documentElement.scrollHeight);
    // Initialize our last scroll position correctly after the initial scroll.
    lastScrollY = window.scrollY;

</script>
</html>
