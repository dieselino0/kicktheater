<!DOCTYPE html>
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Chat Overlay</title>
    <style>
        /* Animation */
        @keyframes fadeInUp {
            from {
                transform: translate3d(0, 40px, 0)
            }

            to {
                transform: translate3d(0, 0, 0);
                opacity: 1
            }
        }
			::-webkit-scrollbar {
  width: 8px;
}

::-webkit-scrollbar-track {
  background: black;
  border-radius: 5px;
}

::-webkit-scrollbar-thumb {
  background-color: #777;
  border-radius: 5px;}
        .animate {
            animation-duration: 0.3s;
            animation-fill-mode: both;
            -webkit-animation-duration: 0.3s;
            -webkit-animation-fill-mode: both;
            opacity: 0;
            animation-name: fadeInUp;
            -webkit-animation-name: fadeInUp;
        }
   body {
  margin: 0;
  height: 8500px;
  position: relative;
  overflow-x:hidden;
  overflow-y:auto;
}
#loading
{
opacity:0;
}
        @-webkit-keyframes fadeInUp {
            from {
                transform: translate3d(0, 40px, 0)
            }

            to {
                transform: translate3d(0, 0, 0);
                opacity: 1
            }
        }

        .animate {
            animation-duration: 0.3s;
            animation-fill-mode: both;
            -webkit-animation-duration: 0.3s;
            -webkit-animation-fill-mode: both;
            opacity: 0;
            animation-name: fadeInUp;
            -webkit-animation-name: fadeInUp;
        }

        @keyframes fadeOut {
            from {
                opacity: 1
            }

            to {
                opacity: 0
            }
        }

        @-webkit-keyframes fadeOut {
            from {
                opacity: 1
            }

            to {
                opacity: 0
            }
        }

        .fade {
            animation-duration: 0.5s;
            animation-fill-mode: both;
            -webkit-animation-duration: 0.5s;
            -webkit-animation-fill-mode: both;
            animation-name: fadeOut;
            -webkit-animation-name: fadeOut;
        }



#chat-container {
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  font-size: 20px;
  width: calc(100% - 20px);
  padding: 10px;
  position: absolute;
  bottom: 0;
  overflow: hidden; /* Enable vertical scrolling */
  background-color: transparent;
  color: white;
  font-weight: 800;
  word-break: break-word;
}

        .chat_line {
            line-height: 30px;
        }

        .user_info {
            display: inline-block;
        }

        .colon {
            margin-right: 8px;
        }

        .emote {
            max-width: 75px;
            max-height: 25px;
            margin-right: 4px;
            vertical-align: middle;
        }

        .badge {
            width: 16px;
            height: 16px;
            margin-right: 2px;
            margin-bottom: 3px;
            vertical-align: middle;
            border-radius: 10%;
        }

        img .emoji {
            max-width: 75px !important;
            max-height: 25px !important;
            margin-right: 4px !important;
            vertical-align: middle !important;
        }
    </style>
</head>
<body>
    <div id="chat-container">
        <span id="loading"></span>
    </div>
    <script src="https://unpkg.com/twemoji@14.0.2/dist/twemoji.min.js" crossorigin="anonymous"></script>
<script>
const urlParams = new URLSearchParams(window.location.search);
let user = urlParams.get('user'); // Changed to 'let' to allow modification
const customTheme = urlParams.get('customtheme');
const animate = urlParams.get('animate');
const fade = urlParams.get('fade');
const showBadges = urlParams.get('showbadges');
const hideCommands = urlParams.get('hidecommands');
const hideBots = urlParams.get('hidebots');
const textColor = '#' + urlParams.get('textcolor');
const textSize = urlParams.get('textsize');

// If no user is specified, redirect back to the root.
if (!user) {
    window.location.href = '/';
}

// Apply custom CSS theme if provided
if (customTheme) {
    let decodedCss = atob(customTheme);
    let styleSheet = document.createElement("style");
    let head = document.head || document.getElementsByTagName('head')[0];
    styleSheet.type = 'text/css';
    styleSheet.appendChild(document.createTextNode(decodedCss));
    console.log(decodedCss);
    head.appendChild(styleSheet);
}

// Global variable to hold subscriber badges data
let subBadges;


// --- 2. Fetch Channel Information ---

/**
 * Fetches channel data from the Kick API, including the channel ID and subscriber badges.
 * @param {string} username - The Kick username.
 * @returns {Promise<any>} A promise that resolves with the fetched data.
 */
async function fetchData(username) {
    let response;
    // Retry fetching until successful, to handle temporary network or API issues.
    while (!response || !response.ok) {
        try {
            response = await fetch(`https://kick.com/api/v2/channels/${username}`);
            if (!response.ok) {
                console.log(`Failed to fetch data: ${response.status}`, user);
                // Kick sometimes uses '-' instead of '_' for usernames in URLs
                if (response.status === 404 && user.includes('_')) {
                    user = user.replace(/_/g, '-');
                    username = username.replace(/_/g, '-');
                }
                // Wait for 5 seconds before retrying
                await new Promise(resolve => setTimeout(resolve, 5000));
            }
        } catch (error) {
            console.log(`Error fetching data: ${error}`, user);
            await new Promise(resolve => setTimeout(resolve, 5000));
        }
    }
    return response;
}

/**
 * Initializes the process by fetching channel info and then starting the main application.
 */
async function getChannelInfo() {
    const response = await fetchData(user);
    const channelData = await response.json();

    console.log("Response from Kick API:", response);
    console.log(`Successfully fetched data for user: ${user}`);
    console.log(`Chatroom ID: ${channelData.chatroom.id}`);

    // Sort subscriber badges by month, descending, to easily find the correct one.
    subBadges = channelData.subscriber_badges;
    subBadges.sort((a, b) => (a.months > b.months) ? -1 : 1);

    return channelData.chatroom.id;
}


// --- 3. WebSocket Connection & Main Logic ---

/**
 * Main function to connect to WebSocket and handle incoming messages.
 * @param {string} channelId - The ID of the chatroom to connect to.
 */
function main(channelId) {
    // --- User-Provided Pusher Credentials ---
    const key = "4912e76426d255ae4a90";
    const cluster = "us2";
    // The 'app_id' and 'secret' are for server-side use only and are not used here.
    // Exposing your 'secret' in client-side code is a major security risk.

    // Establish WebSocket connection using your credentials
    const socket = new WebSocket(`wss://ws-${cluster}.pusher.com/app/${key}?protocol=7&client=js&version=7.6.0&flash=false`);

    console.log("WebSocket connection initiated to your custom Pusher instance.");
    console.log(socket);

    socket.onopen = () => {
        console.log("Connected to your Pusher instance.");
        document.getElementById('loading').innerHTML = '<img src="https://files.kick.com/emotes/26/full/2x.png" class="badge gift"></img> Connected to custom Pusher';
        setTimeout(() => {
            document.getElementById('loading').style.display = 'none';
        }, 1000);
        
        // IMPORTANT: This now subscribes to a channel on YOUR Pusher app.
        // You must have a backend server using your App ID and Secret to push events to this channel.
        const channelToSubscribe = `private-chat-channel-${channelId}`; // Example channel name
        
        socket.send(JSON.stringify({
            event: 'pusher:subscribe',
            data: {
                auth: '', // NOTE: Private channels require a server-side authentication signature.
                channel: channelToSubscribe
            }
        }));
    };

    socket.onmessage = (event) => {
        parseMessage(event.data);
    };

    socket.onerror = (error) => {
        console.log(`Error: ${error}`);
    };

    socket.onclose = () => {
        console.log("Connection closed.");
    };

    // Keep the connection alive by sending a ping every 25 seconds
    setInterval(() => {
        socket.send(JSON.stringify({
            event: 'pusher:ping',
            data: {}
        }));
    }, 25000);
}

/**
 * Parses incoming WebSocket messages and routes them to the correct handler.
 * @param {string} rawData - The raw data string from the WebSocket.
 */
function parseMessage(rawData) {
    const message = JSON.parse(rawData);

    // FIX: Handle both stringified JSON (from Kick) and direct JSON objects (from standard Pusher backends).
    let eventData;
    if (typeof message.data === 'string') {
        eventData = JSON.parse(message.data);
    } else {
        eventData = message.data;
    }
    
    if (message.event.startsWith('pusher')) {
        // Pusher-internal events, can be ignored.
    } else if (message.event === 'App\\Events\\ChatMessageEvent') {
        console.log("Message:", eventData);
        handleMessage(eventData);
    } else if (message.event === 'App\\Events\\MessageDeletedEvent') {
        console.log("Deleted:", eventData);
        handleDelete(eventData);
    } else if (message.event === 'App\\Events\\UserBannedEvent') {
        console.log("Banned:", eventData);
        handleBan(eventData);
    } else if (message.event === 'App\\Events\\ChatClearEvent') {
        console.log("Chat Cleared");
        handleClear(eventData);
    } else {
        // Handle custom events from your own backend here
        console.log("Received custom event:", message.event);
        console.log("Data:", eventData);
        
        // Example: If your backend sends a standard message, you can route it
        // This assumes your backend sends an event named 'client-chat-message'
        // with a data structure similar to Kick's.
        if (message.event === 'client-chat-message') {
             handleMessage(eventData);
        }
    }
}


// --- 4. Message & Event Handlers ---

/**
 * Renders a new chat message on the screen.
 * @param {object} messageData - The parsed message object from the API.
 */
function handleMessage(messageData) {
    const messageId = messageData.id;
    let content = messageData.content;
    const username = messageData.sender.username;
    const identity = messageData.sender.identity;

    if (hideCommands === 'true') {
        if (content.startsWith('!')) return;
    }
    if (hideBots === 'true') {
        const bots = ['nightbot', 'botrix', 'botrixlive', 'streamlabs'];
        if (bots.includes(username.toLowerCase())) return;
    }

    // Replace emote codes with image tags
    const emoteRegex = /\[emote:(\d+):?([\w\s\-~!@#$%^&*()_+=\{}\\|;:'",.<>\/?]+)\]/g;
    const emoteMatches = content.match(emoteRegex);
    if (emoteMatches) {
        for (const emote of emoteMatches) {
            const emoteId = emote.match(/\[emote:(\d+):?/)[1];
            content = content.replace(emote, `<img src="https://files.kick.com/emotes/${emoteId}/full/2x.gif" class="emote">`);
        }
    }

    // Replace emoji codes with image tags
    const emojiRegex = /\[emoji:(\w+)\]/g;
    const emojiMatches = content.match(emojiRegex);
    if (emojiMatches) {
        for (const emoji of emojiMatches) {
            const emojiId = emoji.match(/\[emoji:(\w+)\]/)[1];
            content = content.replace(emoji, `<img src="https://files.kick.com/emojis/${emojiId}.png" class="emote">`);
        }
    }

    // Create the message container element
    let messageElement = document.createElement('div');
    messageElement.classList.add('message-line');
    messageElement.setAttribute('data-id', messageId);
    messageElement.setAttribute('data-sender', username);
    messageElement.setAttribute('data-timestamp', messageData.created_at);

    // Create container for badges and username
    let senderInfoElement = document.createElement('span');
    senderInfoElement.classList.add('sender-info');
    
    // Generate and add badges
    if (showBadges !== 'false') {
        senderInfoElement.innerHTML = generateBadges(messageData);
    } else {
        senderInfoElement.innerHTML = '';
    }

    // Create username element
    let usernameElement = document.createElement('span');
    usernameElement.classList.add('username');
    usernameElement.style.color = identity.color;
    usernameElement.innerHTML = username;

    // Create separator
    let separatorElement = document.createElement('span');
    separatorElement.classList.add('separator');
    separatorElement.innerHTML = ':\u00A0';

    // Append username and separator to the sender info container
    senderInfoElement.appendChild(usernameElement);
    senderInfoElement.appendChild(separatorElement);

    // Create message content element
    let contentElement = document.createElement('span');
    contentElement.classList.add('message-content');
    contentElement.innerHTML = content;

    // Apply text color and size if specified
    if (textColor) {
        contentElement.style.color = textColor;
    }
    if (textSize) {
        messageElement.style.fontSize = textSize;
    }

    // Assemble the full message element
    messageElement.appendChild(senderInfoElement);
    messageElement.appendChild(contentElement);

    // Animate message entry
    if (animate) {
        messageElement.classList.add('hidden');
    }

    // Fade out message after a delay
    if (fade) {
        setTimeout(() => {
            messageElement.classList.add('fade-out');
            setTimeout(() => {
                messageElement.remove();
            }, 1000); // Wait for fade-out animation to complete
        }, fade * 1000);
    }

    // Add the message to the chat container
    const chatContainer = document.getElementById('chat-container');
    chatContainer.appendChild(messageElement);

    // Scroll to the bottom
    chatContainer.scrollTop = chatContainer.scrollHeight;

    // Limit the number of messages on screen to 100 to avoid performance issues
    let messages = document.querySelectorAll('.message-line');
    if (messages.length > 100) {
        messages[0].remove();
    }
}

/**
 * Removes a specific message by its ID.
 * @param {object} data - The deletion event data containing the message ID.
 */
function handleDelete(data) {
    const messageId = data.message.id;
    const messageElement = document.querySelector(`[data-id="${messageId}"]`);
    if (messageElement) {
        messageElement.remove();
    }
}

/**
 * Removes all messages from a specific user.
 * @param {object} data - The ban event data containing the user's information.
 */
function handleBan(data) {
    console.log(data);
    const userId = data.user.id;
    document.querySelectorAll(`[data-sender-id="${userId}"]`).forEach(el => el.remove());
}

/**
 * Removes all messages from the chat display.
 */
function handleClear() {
    document.getElementById('chat-container').innerHTML = '';
}


// --- 5. Badge Generation ---

/**
 * Generates the HTML for a user's badges based on their identity.
 * @param {object} messageData - The message object containing sender identity.
 * @returns {string} An HTML string of <img> tags for the badges.
 */
function generateBadges(messageData) {
    let badgesHtml = '';
    const badges = messageData.sender.identity.badges;

    badges.forEach(badge => {
        const badgeType = badge.type;
        console.log(`Badge found: ${badgeType}`);
        console.log(badge);

        switch (badgeType) {
            case 'broadcaster':
                badgesHtml += '<img src="https://files.kick.com/static/badges/broadcaster.svg" class="badge broadcaster"></img>';
                break;
            case 'moderator':
                badgesHtml += '<img src="https://files.kick.com/static/badges/moderator.svg" class="badge moderator"></img>';
                break;
            case 'vip':
                badgesHtml += `<img src="https://files.kick.com/static/badges/vip.png" class="badge vip" style="--badge-color: ${badge.data.color};"></img>`;
                break;
            case 'og':
                badgesHtml += '<img src="https://files.kick.com/static/badges/og.svg" class="badge OG"></img>';
                break;
            case 'subscriber':
                if (subBadges) {
                    const months = parseInt(badge.count);
                    const bestBadge = subBadges.find(b => b.months === months) || subBadges.find(b => b.months < months);
                    if (bestBadge) {
                        badgesHtml += `<img src="${bestBadge.badge_image.src}" class="badge subscriber"></img>`;
                    }
                }
                break;
            case 'sub_gifter':
                const giftCount = parseInt(badge.count);
                if (giftCount >= 50) {
                    badgesHtml += '<img src="https://files.kick.com/static/badges/sub_gifter/v5.svg" class="badge subgift"></img>';
                } else if (giftCount >= 25) {
                    badgesHtml += '<img src="https://files.kick.com/static/badges/sub_gifter/v4.svg" class="badge subgift"></img>';
                } else if (giftCount >= 10) {
                    badgesHtml += '<img src="https://files.kick.com/static/badges/sub_gifter/v3.svg" class="badge subgift"></img>';
                } else if (giftCount >= 5) {
                    badgesHtml += '<img src="https://files.kick.com/static/badges/sub_gifter/v2.svg" class="badge subgift"></img>';
                } else if (giftCount >= 1) {
                    badgesHtml += '<img src="https://files.kick.com/static/badges/sub_gifter/v1.svg" class="badge subgift"></img>';
                }
                break;
        }
    });

    return badgesHtml;
}


// --- 6. Application Start ---

getChannelInfo().then(channelId => {
    console.log(`Channel ID: ${channelId}`);
    main(channelId);
});
</script>
</body>
<script>
    // The chat won't pause until at least this many messages exist.
    const MIN_MESSAGES_TO_PAUSE = 10;

    // --- STATE VARIABLES ---
    // isPaused: Our single source of truth. true = user has scrolled up, false = auto-scrolling.
    let isPaused = false;
    // lastScrollY: Tracks the last scroll position to detect scroll direction.
    let lastScrollY = window.scrollY;

    // --- CREATE THE "CHAT PAUSED" BUTTON ---
    const pauseButton = document.createElement('button');
    const img = document.createElement("img");
    img.src = "./pause.jpg"; // Make sure this path is correct
    img.style.verticalAlign = "middle";
    img.style.width = "21px";
    img.style.height = "21px";
    img.style.marginRight = "10px";

    pauseButton.appendChild(img);
    pauseButton.appendChild(document.createTextNode('Chat Paused - Click to resume'));
    // Apply styles
    Object.assign(pauseButton.style, {
        position: 'fixed',
        bottom: '30px',
        left: '50%',
        transform: 'translateX(-50%)',
        width: '80%',
        padding: '10px 20px',
        fontSize: '18px',
        fontWeight: '600',
        background: 'rgba(0, 0, 0, 0.85)',
        color: 'white',
        display: 'none', // Initially hidden
        zIndex: '1000',
        borderRadius: '25px',
        border: '2px solid #00ff00', // Lime green
        cursor: 'pointer',
        boxShadow: '0 4px 12px rgba(0,0,0,0.4)'
    });
    document.body.appendChild(pauseButton);


    // --- FUNCTIONS ---

    /**
     * Resumes the chat, hiding the pause button, showing all messages, and scrolling to the bottom.
     */
    function resumeChat() {
        isPaused = false;
        pauseButton.style.display = 'none';

        // Show any messages that were hidden while paused
        document.querySelectorAll('.chat_line.animate[data-hidden="true"]').forEach(element => {
            element.style.display = '';
            element.removeAttribute('data-hidden');
        });

        // Scroll smoothly to the bottom
        window.scrollTo({
            top: document.documentElement.scrollHeight,
            behavior: 'smooth'
        });
        
        // After scrolling, update lastScrollY to the new bottom position
        // Use a small delay to allow the scroll to complete
        setTimeout(() => {
            lastScrollY = window.scrollY;
        }, 300); // 300ms should be enough for a smooth scroll
    }

    /**
     * This function is the heart of the auto-scroll and pause logic.
     * It's called by the MutationObserver whenever the chat content changes.
     */
    function handleChatUpdate(mutationsList) {
        let hasNewMessage = false;
        for (const mutation of mutationsList) {
            if (mutation.type === 'childList') {
                for (const node of mutation.addedNodes) {
                    // Check if the added node is a new chat line we care about
                    if (node.nodeType === 1 && node.classList.contains('chat_line') && node.classList.contains('animate')) {
                        hasNewMessage = true;
                        if (isPaused) {
                            // If paused, hide the new message and mark it
                            node.style.display = 'none';
                            node.setAttribute('data-hidden', 'true');
                        }
                    }
                }
            }
        }

        // If new messages arrived AND we are not paused, scroll to the bottom.
        if (hasNewMessage && !isPaused) {
            window.scrollTo(0, document.documentElement.scrollHeight);
            // After auto-scrolling, update our last known position to the new bottom.
            lastScrollY = document.documentElement.scrollHeight - window.innerHeight;
        }
    }


    /**
     * Checks the user's scroll direction to determine if the chat should be paused.
     * It also checks if the user has scrolled back to the very bottom to resume.
     */
    function checkScrollPosition() {
        const chatLineCount = document.querySelectorAll('.chat_line.animate').length;
        if (chatLineCount < MIN_MESSAGES_TO_PAUSE) {
            return; // Don't allow pausing if chat is too short
        }

        const currentScrollY = window.scrollY;
        
        // --- PAUSE LOGIC ---
        // If the user scrolls UP (and we aren't already paused), pause the chat.
        // We add a small buffer (currentScrollY > 0) to avoid issues at the very top.
        if (currentScrollY < lastScrollY && !isPaused && currentScrollY > 0) {
            isPaused = true;
            pauseButton.style.display = 'block';
        }

        // --- RESUME LOGIC ---
        // If the user scrolls all the way to the bottom, resume the chat.
        const isAtVeryBottom = (window.innerHeight + currentScrollY) >= document.documentElement.scrollHeight;
        if (isAtVeryBottom && isPaused) {
            resumeChat();
        }

        // ALWAYS update the last scroll position for the next check.
        lastScrollY = currentScrollY;
    }


    // --- SETUP OBSERVERS AND EVENT LISTENERS ---

    // Create and start the MutationObserver to watch for new messages
    const observer = new MutationObserver(handleChatUpdate);
    observer.observe(document.body, {
        childList: true,
        subtree: true
    });

    // When the pause button is clicked, resume the chat.
    pauseButton.addEventListener('click', resumeChat);

    // Use a timeout to prevent the scroll check from running too frequently
    let scrollTimeout;
    window.addEventListener('scroll', () => {
        clearTimeout(scrollTimeout);
        scrollTimeout = setTimeout(checkScrollPosition, 50); // Check 50ms after the last scroll event
    });

    // --- INITIAL SCROLL ---
    // Start scrolled to the bottom when the page loads.
    window.scrollTo(0, document.documentElement.scrollHeight);
    // Initialize our last scroll position correctly after the initial scroll.
    lastScrollY = window.scrollY;

</script>
</html>
