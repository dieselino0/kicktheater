<!DOCTYPE html>
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Chat Overlay</title>
    <style>
        /* Animation */
        @keyframes fadeInUp {
            from {
                transform: translate3d(0, 40px, 0)
            }

            to {
                transform: translate3d(0, 0, 0);
                opacity: 1
            }
        }
			::-webkit-scrollbar {
  width: 8px;
}

::-webkit-scrollbar-track {
  background: black;
  border-radius: 5px;
}

::-webkit-scrollbar-thumb {
  background-color: #777;
  border-radius: 5px;}
        .animate {
            animation-duration: 0.3s;
            animation-fill-mode: both;
            -webkit-animation-duration: 0.3s;
            -webkit-animation-fill-mode: both;
            opacity: 0;
            animation-name: fadeInUp;
            -webkit-animation-name: fadeInUp;
        }
   body {
  margin: 0;
  height: 8500px;
  position: relative;
  overflow-x:hidden;
  overflow-y:auto;
}
#loading
{
opacity:0;
}
        @-webkit-keyframes fadeInUp {
            from {
                transform: translate3d(0, 40px, 0)
            }

            to {
                transform: translate3d(0, 0, 0);
                opacity: 1
            }
        }

        .animate {
            animation-duration: 0.3s;
            animation-fill-mode: both;
            -webkit-animation-duration: 0.3s;
            -webkit-animation-fill-mode: both;
            opacity: 0;
            animation-name: fadeInUp;
            -webkit-animation-name: fadeInUp;
        }

        @keyframes fadeOut {
            from {
                opacity: 1
            }

            to {
                opacity: 0
            }
        }

        @-webkit-keyframes fadeOut {
            from {
                opacity: 1
            }

            to {
                opacity: 0
            }
        }

        .fade {
            animation-duration: 0.5s;
            animation-fill-mode: both;
            -webkit-animation-duration: 0.5s;
            -webkit-animation-fill-mode: both;
            animation-name: fadeOut;
            -webkit-animation-name: fadeOut;
        }



#chat-container {
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  font-size: 20px;
  width: calc(100% - 20px);
  padding: 10px;
  position: absolute;
  bottom: 0;
  overflow: hidden; /* Enable vertical scrolling */
  background-color: transparent;
  color: white;
  font-weight: 800;
  word-break: break-word;
}

        .chat_line {
            line-height: 30px;
        }

        .user_info {
            display: inline-block;
        }

        .colon {
            margin-right: 8px;
        }

        .emote {
            max-width: 75px;
            max-height: 25px;
            margin-right: 4px;
            vertical-align: middle;
        }

        .badge {
            width: 16px;
            height: 16px;
            margin-right: 2px;
            margin-bottom: 3px;
            vertical-align: middle;
            border-radius: 10%;
        }

        img .emoji {
            max-width: 75px !important;
            max-height: 25px !important;
            margin-right: 4px !important;
            vertical-align: middle !important;
        }
    </style>
</head>
<body>
    <div id="chat-container">
        <span id="loading"></span>
    </div>
    <script src="https://unpkg.com/twemoji@14.0.2/dist/twemoji.min.js" crossorigin="anonymous"></script>
<script>
// 1. Read customization options from the URL query parameters
const urlParams = new URLSearchParams(window.location.search);
let user = urlParams.get("user");
const animate = urlParams.get("animate");
const fade = urlParams.get("fade");
const showBadges = urlParams.get("badges");
const hideCommands = urlParams.get("commands");
const hideBots = urlParams.get("bots");
const textColor = '#' + urlParams.get("textcolor");
const textSize = urlParams.get("textsize");
const customTheme = urlParams.get("customtheme");

// Global variable to store subscriber badges
let subscriberBadges;

// If no user is specified in the URL, redirect to the homepage
if (!user) {
    window.location.replace('/');
}


//
// --- API Data Fetching ---
//

/**
 * Asynchronously fetches data from a given URL with a retry mechanism.
 * Handles 404 errors for Kick usernames by replacing underscores with hyphens.
 * @param {string} url - The URL to fetch.
 * @returns {Promise<Response>} - The fetch Response object.
 */
async function fetchData(url) {
    let response;
    // Loop until we get a successful response
    while (!response || !response.ok) {
        try {
            response = await fetch(url);
            if (!response.ok) {
                console.log("Error fetching data: " + response.status);
                console.log("User:", user);
                // Handle Kick API quirk where usernames with '_' might be accessible with '-'
                if (response.status == "404" && user.includes('_')) {
                    console.log("Attempting to fix username by replacing '_' with '-'");
                    user = user.replace(/_/g, '-');
                    url = url.replace(/_/g, '-');
                }
                // Wait 1 second before retrying
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
        } catch (error) {
            console.log("Fetch exception: " + error);
            console.log("User:", user);
            await new Promise(resolve => setTimeout(resolve, 1000));
        }
    }
    return response;
}

/**
 * Fetches the channel information from the Kick API to get the chatroom ID.
 * @returns {Promise<number>} - The chatroom ID.
 */
async function getChannelInfo() {
    console.log("Fetching channel info for user: " + user);
    const apiUrl = "https://kick.com/api/v1/channels/" + user;
    const response = await fetchData(apiUrl);
    const channelData = await response.json();

    console.log("Successfully fetched channel data.");
    console.log("Chatroom ID:", channelData.chatroom.id);

    // Store and sort subscriber badges by month count for later use
    subscriberBadges = channelData.subscriber_badges;
    subscriberBadges.sort((a, b) => a.months > b.months ? 1 : -1);

    return channelData.chatroom.id;
}


//
// --- WebSocket and Main Logic ---
//

// Start the process by getting the channel info, then connect to the WebSocket
getChannelInfo().then(chatroomId => {
    main(chatroomId);
});

/**
 * Main function to connect to Kick's chat via WebSocket (Pusher).
 * @param {number} chatroomId - The ID of the chatroom to connect to.
 */
function main(chatroomId) {
    // Kick.com's public Pusher WebSocket endpoint
    const pusherUrl = "wss://ws-us2.pusher.com/app/32cbd69e4b950bf97679?protocol=7&client=js&version=8.4.0&flash=false";
    const socket = new WebSocket(pusherUrl);

    console.log("Connecting to Pusher...");

    socket.onopen = () => {
        console.log("Connected to Pusher.");

        // Update loading status on the page
        const loadingElement = document.getElementById("loading");
        loadingElement.innerHTML = "Chat connected by Cx Watcher";
        setTimeout(() => {
            loadingElement.style.display = "none";
        }, 10000);

        // Subscribe to the chatroom's event channel
        const subscribePayload = {
            event: "pusher:subscribe",
            data: {
                auth: '',
                channel: `chatrooms.${chatroomId}.v2`
            }
        };
        socket.send(JSON.stringify(subscribePayload));
        
        // Apply custom theme if provided in the URL
        if (customTheme) {
            try {
                let decodedCss = atob(customTheme); // Decode from Base64
                let styleElement = document.createElement("style");
                styleElement.type = "text/css";
                styleElement.appendChild(document.createTextNode(decodedCss));
                document.head.appendChild(styleElement);
                console.log("Custom theme applied.");
            } catch (e) {
                console.error("Failed to apply custom theme:", e);
            }
        }
    };

    socket.onerror = (error) => {
        console.error("WebSocket Error: ", error);
    };

    socket.onmessage = (event) => {
        parseMessage(event.data);
    };

    // Send a ping every 60 seconds to keep the connection alive
    setInterval(() => {
        socket.send(JSON.stringify({ event: "pusher:ping", data: {} }));
    }, 60000);
}


//
// --- Message Parsing and Handling ---
//

/**
 * Parses the incoming message from the WebSocket.
 * @param {string} rawData - The raw data string from the WebSocket message.
 */
function parseMessage(rawData) {
    const pusherEvent = JSON.parse(rawData);
    
    // Pusher's data field is a stringified JSON, so it needs to be parsed again
    const eventData = JSON.parse(pusherEvent.data);

    // Route the event to the correct handler based on the event name
    switch (pusherEvent.event) {
        case "App\\Events\\ChatMessageEvent":
            console.log("Received Message:", eventData);
            handleMessage(eventData);
            break;
        case "App\\Events\\MessageDeletedEvent":
            console.log("Message Deleted:", eventData);
            handleDelete(eventData);
            break;
        case "App\\Events\\UserBannedEvent":
            console.log("User Banned:", eventData);
            handleBan(eventData);
            break;
        case "App\\Events\\ChatroomClearEvent":
            console.log("Chat Cleared:", eventData);
            handleClear();
            break;
        // Ignore internal pusher events like 'pusher:pong'
        case "pusher:pong":
            break; 
        default:
            if (!pusherEvent.event.startsWith("pusher")) {
                 console.log("Unhandled Event:", pusherEvent.event, eventData);
            }
            break;
    }
}


//
// --- DOM Manipulation ---
//

/**
 * Creates and displays a new chat message in the overlay.
 * @param {object} messageData - The parsed message object.
 */
function handleMessage(messageData) {
    const messageId = messageData.id;
    let content = messageData.content;
    const username = messageData.sender.username;
    const timestamp = messageData.created_at;

    // Optional: Hide messages that are commands
    if (hideCommands === "true" && content.startsWith('!')) {
        return;
    }

    // Optional: Hide messages from known bots
    if (hideBots === 'true') {
        const knownBots = ["livebot", "corardbot", 'botrixlive', "ryu7zbot", "botrix"];
        if (knownBots.includes(username.toLowerCase())) {
            return;
        }
    }

    // Replace Kick's custom emote tags with <img> elements
    content = content.replace(/\[emote:(\d+):.*?\]/g, (match, emoteId) => {
        return `<img src="https://files.kick.com/emotes/${emoteId}/fullsize" class="emote">`;
    });

    // Replace Kick's emoji tags with <img> elements
    content = content.replace(/\[emoji:(\w+)\]/g, (match, emojiName) => {
        return `<img src="https://dbxmjjzl5pc1g.cloudfront.net/9ad84c86-99f0-4f0a-8e1a-baccf20502b9/images/emojis/${emojiName}.png" class="emote">`;
    });

    // Create the chat line container
    const lineElement = document.createElement("div");
    lineElement.classList.add("chat_line");
    lineElement.setAttribute("data-id", messageId);
    lineElement.setAttribute("data-sender", username);
    lineElement.setAttribute("data-timestamp", timestamp);

    // Create the user info container (badges, username, colon)
    const userInfoElement = document.createElement('span');
    userInfoElement.classList.add("user_info");

    // Add badges if enabled
    if (showBadges === "true") {
        userInfoElement.innerHTML = generateBadgesHTML(messageData);
    }

    // Create the username span
    const usernameElement = document.createElement('span');
    usernameElement.classList.add("username");
    usernameElement.style.color = messageData.sender.identity.color; // Use user's chosen name color
    usernameElement.innerHTML = username;

    // Create the colon
    const colonElement = document.createElement('span');
    colonElement.classList.add("colon");
    colonElement.innerHTML = ": ";

    // Append username and colon to the user info container
    userInfoElement.appendChild(usernameElement);
    userInfoElement.appendChild(colonElement);

    // Create the message content span
    const messageContentElement = document.createElement('span');
    messageContentElement.classList.add("message_content");
    messageContentElement.innerHTML = content;

    // Apply custom text color and size if specified
    if (textColor) {
        messageContentElement.style.color = textColor;
    }
    if (textSize) {
        lineElement.style.fontSize = textSize;
    }

    // Assemble the final chat line
    lineElement.appendChild(userInfoElement);
    lineElement.appendChild(messageContentElement);

    // Add animation class if specified
    if (animate) {
        lineElement.classList.add("animate");
    }

    // Set up fade-out if specified
    if (fade) {
        setTimeout(() => {
            lineElement.classList.add("fade");
            setTimeout(() => lineElement.remove(), 1000); // Remove from DOM after fade animation
        }, fade * 1000);
    }
    
    // Limit the number of messages on screen to prevent performance issues
    const chatLines = document.querySelectorAll(".chat_line");
    if (chatLines.length > 250) {
        chatLines[0].remove();
    }

    // Add the new message to the chat container
    document.getElementById("chat-container").appendChild(lineElement);
}

/**
 * Handles the message deletion event.
 * @param {object} deleteData - The data for the deleted message.
 */
function handleDelete(deleteData) {
    const messageId = deleteData.message.id;
    const messageElement = document.querySelector(`[data-id="${messageId}"]`);
    if (messageElement) {
        messageElement.remove();
    }
}

/**
 * Handles the user ban event by removing all of their messages.
 * @param {object} banData - The data for the banned user.
 */
function handleBan(banData) {
    const bannedUsername = banData.user.username;
    const userMessages = document.querySelectorAll(`[data-sender="${bannedUsername}"]`);
    userMessages.forEach(msg => msg.remove());
}

/**
 * Handles the chat clear event.
 */
function handleClear() {
    document.getElementById("chat-container").innerHTML = '';
}

/**
 * Generates the HTML for a user's badges.
 * @param {object} messageData - The message object containing sender identity.
 * @returns {string} - The HTML string for the user's badges.
 */
function generateBadgesHTML(messageData) {
    let badgesHTML = '';
    const badges = messageData.sender.identity.badges;

    badges.forEach(badge => {
        switch (badge.type) {
            case "broadcaster":
                badgesHTML += `<img src="https://cxwatcher.github.io/broadcaster.svg" class="badge Channel-Host" title="Broadcaster">`;
                break;
            case "founder":
                const months = badge.count;
                const founderBadge = subscriberBadges.find(b => b.months === months) || { badge_image: { src: "https://cxwatcher.github.io/founder.svg" } };
                badgesHTML += `<img src="${founderBadge.badge_image.src}" class="badge Founder" title="Founder">`;
                break;
            case "subscriber":
                if (subscriberBadges) {
                    const months = parseInt(badge.count);
                    // Find the exact badge, or the highest one below the user's count
                    const subBadge = subscriberBadges.find(b => b.months === months) || subscriberBadges.slice().reverse().find(b => b.months < months);
                    const badgeUrl = subBadge ? subBadge.badge_image.src : "https://cxwatcher.github.io/subscriber.svg";
                    badgesHTML += `<img src="${badgeUrl}" class="badge Subscriber" title="Subscriber">`;
                }
                break;
            case 'sub_gifter':
                const giftCount = parseInt(badge.count);
                let giftBadgeUrl = "https://cxwatcher.github.io/gift_blue.svg"; // Default (0-24)
                if (giftCount >= 200) giftBadgeUrl = "https://cxwatcher.github.io/gift_green.svg";
                else if (giftCount >= 100) giftBadgeUrl = "https://cxwatcher.github.io/gift_yellow.svg";
                else if (giftCount >= 50) giftBadgeUrl = "https://cxwatcher.github.io/gift_red.svg";
                else if (giftCount >= 25) giftBadgeUrl = "https://cxwatcher.github.io/gift_mauve.svg";
                badgesHTML += `<img src="${giftBadgeUrl}" class="badge subgift" title="Sub Gifter">`;
                break;
            case "moderator":
                badgesHTML += `<img src="https://cxwatcher.github.io/mod.svg" class="badge Moderator" title="Moderator">`;
                break;
            case "staff":
                badgesHTML += `<img src="https://static.defalt.fr/kick/admin.svg" class="badge Staff" title="Staff">`;
                break;
            case "verified":
                badgesHTML += `<img src="https://cxwatcher.github.io/verified.svg" class="badge Verified" title="Verified">`;
                break;
            case 'og':
                badgesHTML += `<img src="https://cxwatcher.github.io/og.svg" class="badge OG" title="OG">`;
                break;
            case "vip":
                badgesHTML += `<img src="https://cxwatcher.github.io/vip.svg" class="badge VIP" title="VIP">`;
                break;
        }
    });
    return badgesHTML;
}
</script>
</body>
<script>
    // The chat won't pause until at least this many messages exist.
    const MIN_MESSAGES_TO_PAUSE = 10;
    // A tiny pixel buffer for scroll-up detection to prevent false positives from minor layout shifts.
    // This is NOT a resume tolerance zone, it's a technical buffer for the pause trigger.
    const PAUSE_SCROLL_BUFFER = 5;

    // --- STATE VARIABLES ---
    let isPaused = false;
    let lastScrollY = window.scrollY;
    // Flag to tell our scroll listener to ignore scrolls triggered by our own code.
    let isProgrammaticScroll = false;

    // --- CREATE THE "CHAT PAUSED" BUTTON ---
    const pauseButton = document.createElement('button');
    const img = document.createElement("img");
    img.src = "./pause.jpg"; // Make sure this path is correct
    img.style.verticalAlign = "middle";
    img.style.width = "21px";
    img.style.height = "21px";
    img.style.marginRight = "10px";

    pauseButton.appendChild(img);
    pauseButton.appendChild(document.createTextNode('Chat Paused - Click to resume'));
    Object.assign(pauseButton.style, {
        position: 'fixed',
        bottom: '30px',
        left: '50%',
        transform: 'translateX(-50%)',
        width: '80%',
        maxWidth: '400px',
        padding: '10px 20px',
        fontSize: '18px',
        fontWeight: '600',
        background: 'rgba(0, 0, 0, 0.85)',
        color: 'white',
        display: 'none',
        zIndex: '1000',
        borderRadius: '25px',
        border: '2px solid #00ff00',
        cursor: 'pointer',
        boxShadow: '0 4px 12px rgba(0,0,0,0.4)'
    });
    document.body.appendChild(pauseButton);


    // --- FUNCTIONS ---

    /**
     * A "safe" scroll function that manages the programmatic scroll flag.
     * This is the ONLY function that should be used to scroll the page programmatically.
     */
    function scrollToBottom(behavior = 'auto') {
        isProgrammaticScroll = true;
        window.scrollTo({
            top: document.documentElement.scrollHeight,
            behavior: behavior
        });

        // After the scroll is likely finished, reset the flag and update lastScrollY
        // so the next user scroll is measured correctly.
        const resetDelay = behavior === 'smooth' ? 350 : 100;
        setTimeout(() => {
            lastScrollY = window.scrollY; // Sync lastScrollY to the new bottom
            isProgrammaticScroll = false;
        }, resetDelay);
    }

    /**
     * Resumes the chat.
     */
    function resumeChat() {
        isPaused = false;
        pauseButton.style.display = 'none';

        document.querySelectorAll('.chat_line.animate[data-hidden="true"]').forEach(element => {
            element.style.display = '';
            element.removeAttribute('data-hidden');
        });

        // Use our safe scroll function
        scrollToBottom('smooth');
    }

    /**
     * Handles new messages added to the DOM.
     */
    function handleChatUpdate(mutationsList) {
        let hasNewMessage = false;
        for (const mutation of mutationsList) {
            if (mutation.type === 'childList') {
                for (const node of mutation.addedNodes) {
                    if (node.nodeType === 1 && node.classList.contains('chat_line') && node.classList.contains('animate')) {
                        hasNewMessage = true;
                        if (isPaused) {
                            node.style.display = 'none';
                            node.setAttribute('data-hidden', 'true');
                        }
                    }
                }
            }
        }

        if (hasNewMessage && !isPaused) {
            // Use our safe scroll function for instant scrolling
            scrollToBottom('auto');
        }
    }

    /**
     * Checks the user's scroll position to determine if the chat should be paused or resumed.
     * This is the original logic, but now protected by the isProgrammaticScroll flag.
     */
    function checkScrollPosition() {
        // **THE CRITICAL FIX**: If the scroll was triggered by our code, do nothing.
        if (isProgrammaticScroll) {
            return;
        }

        const chatLineCount = document.querySelectorAll('.chat_line.animate').length;
        if (chatLineCount < MIN_MESSAGES_TO_PAUSE) {
            return;
        }

        const currentScrollY = window.scrollY;

        // --- PAUSE LOGIC ---
        // Pause if the user has scrolled up by a meaningful amount.
        // The buffer prevents tiny 1-2px jitters from pausing the chat.
        if ((lastScrollY - currentScrollY) > PAUSE_SCROLL_BUFFER && !isPaused) {
            isPaused = true;
            pauseButton.style.display = 'block';
        }

        // --- RESUME LOGIC ---
        // Resumes if the user is scrolled precisely to the bottom.
        // `Math.ceil` helps account for sub-pixel rendering differences.
        const isAtVeryBottom = (window.innerHeight + Math.ceil(currentScrollY)) >= document.documentElement.scrollHeight;
        if (isAtVeryBottom && isPaused) {
            resumeChat();
        }

        // ALWAYS update the last scroll position for the next user scroll check.
        lastScrollY = currentScrollY;
    }


    // --- SETUP OBSERVERS AND EVENT LISTENERS ---
    const observer = new MutationObserver(handleChatUpdate);
    observer.observe(document.body, { childList: true, subtree: true });

    pauseButton.addEventListener('click', resumeChat);

    let scrollTimeout;
    window.addEventListener('scroll', () => {
        clearTimeout(scrollTimeout);
        scrollTimeout = setTimeout(checkScrollPosition, 50);
    });

    // --- INITIALIZATION ---
    window.addEventListener('load', () => {
        // Use our safe scroll function for the initial page load.
        scrollToBottom('auto');
    });

</script>
</html>
